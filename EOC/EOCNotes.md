
### Effective Objective-C:

- [x] 'Calling a method' OR 'sending a message' in Objective C? : [解答](EOC01.md)
- [x] forward declaring: [解答](EOC02.md)
- [x] 字面量语法： [解答](EOC03.md)
- [x] 常型常量: [解答](EOC04.md)
- [x] 用枚举表示状态、选项、状态码： [解答](EOC05.md)
- [x] 理解“属性”这一概念 ： 参见上面的thoughts部分-> 属性以及ARC
- [x] 在对象内部尽量直接访问实例变量: 直接访问实例变量不会触发 KVO
- [x] 理解‘对象等同性’这一概念： 是指向同一对象 or 属性一样
- [x] 以‘类族模式’隐藏实现细节： 定义一个基类，然后继承实现
- [x] 在既有类中使用关联对象存放自定义数据：参照上面的thoughts部分 -> Category中添加属性用到了这个，但是谨慎使用
- [x] 理解objc-msgSend的作用： [解答](EOC11.md)
- [x] 理解消息转发机制： [解答](thoughts/消息转发.md)
- [x] 用“方法调配技术“调试”黑和方法“： [解答](thoughts/EOC13.md)
- [x] 理解‘类对象’的用意： 参见上面的Runtime部分
- [x] 用前缀避免命名空间冲突：[解答](EOC15.md)
- [x] 提供‘全能初始化方法’：[解答](EOC16.md)
- [x] 实现description方法：覆写description/debugDescription方法，方便debug
- [x] 尽量使用不可变对象： 声明 nonatomic, readonly, copy/assign
- [x] 使用清晰而协调的命名方式
- [x] 为私有方法名添加前缀：加上比如这样的前缀：p_
- [x] 理解Objective-C的错误模型： [解答](EOC21.md)
- [x] 理解NSCopying协议： [解答](EOC22.md)
- [x] 通过委托与数据源协议进行对象间通信: 参照上方protocol部分
- [x] 将类的实现代码分散到便于管理的数个分类之中: [解答](EOC24.md)
- [x] 总是为第三方类的分类名称加前缀: [解答](EOC25.md)
- [x] 勿在分类中声明属性: [解答](EOC26.md)
- [x] 使用‘class-continuation分类’隐藏实现细节: [解答](EOC27.md)
- [x] 通过协议提供匿名对象: [解答](EOC28.md)
- [x] 理解引用计数: 上面thoughts部分 -> ARC内存管理 strong/weak/copy [补充](EOC29.md)
- [x] 以ARC简化引用计数: [解答](EOC30.md)
- [x] 在dealloc方法中之释放引用并解除监听
- [x] 编写‘异常安全代码’时留意内存管理问题
- [x] 以弱引用避免保留环
- [x] 以‘自动释放池块’降低内存峰值
- [x] 用‘僵尸对象’调试内存管理问题
- [x] 不要使用retainCount
- [x] 理解‘块’这一概念： 参见blocks: [解答](thoughts/blocks.md) [补充](EOC37.md)
- [x] 为常用的块类型创建typedef: [解答](EOC38.md)
- [x] 用handler块降低代码分散程度: [解答](EOC39.md)
- [x] 用块引用其所属对象是不要出现保留环: [解答](EOC40.md)
- [x] 多用派发队列，少用同步锁
- [x] 多用GCD，少用performSelector系列方法: [解答](EOC42.md)
- [x] 掌握GCD几操作队列的使用时机: [解答](EOC43.md)
- [x] 通过Dispatch Group机制，根据系统资源状况来执行任务: [解答](EOC44.md)
- [x] 使用 dipatch_once 来执行只需运行一次的线程安全代码: 参见实现单例模式： [解答](oc/singleton.md)
- [x] 不要使用diapatch_get_current_queue
- [x] 熟悉系统框架
- [x] 多用块枚举，少用for循环: [解答](EOC48.md)
- [x] 对自定义其内存管理语义的 collection 使用无缝桥接: [解答](EOC49.md)
- [x] 构建缓存时选用 NSCache 而非 NSDictionary: [解答](EOC50.md)
- [x] 精简 initialize 与 load的实现代码
- [x] 别忘了NSTimer会保留其目标对象